<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>

  <body style="margin:0; overflow:hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets2.mind;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- SOLO TARGET 0 -->
      <a-entity mindar-image-target="targetIndex: 0">
        <a-gltf-model
          id="modelo"
          src="./piezas2.glb"
          position="0 0 0"
          rotation="0 0 0"
          scale="2.5 2.5 2.5"
          parts-dragger="
            horizontalNode: pieza1;
            verticalNode: pieza2;
            moveSpeed: 0.002;
            zoomSpeed: 0.002;
            minScale: 0.1;
            maxScale: 3.0
          "
        ></a-gltf-model>
      </a-entity>
    </a-scene>

    <script>
      AFRAME.registerComponent("parts-dragger", {
        schema: {
          horizontalNode: { type: "string", default: "pieza1" },
          verticalNode:   { type: "string", default: "pieza2" },
          moveSpeed:      { type: "number", default: 0.002 },
          zoomSpeed:      { type: "number", default: 0.002 },
          minScale:       { type: "number", default: 0.1 },
          maxScale:       { type: "number", default: 3.0 },
        },

        init: function () {
          this.modelRoot = null;
          this.piezaH = null;
          this.piezaV = null;

          this.selected = null; // "H" o "V"
          this.dragging = false;
          this.pinching = false;

          this.prevX = 0;
          this.prevY = 0;
          this.prevPinchDist = 0;

          this.raycaster = new THREE.Raycaster();
          this.ndc = new THREE.Vector2();

          this.onModelLoaded = this.onModelLoaded.bind(this);
          this.onTouchStart  = this.onTouchStart.bind(this);
          this.onTouchMove   = this.onTouchMove.bind(this);
          this.onTouchEnd    = this.onTouchEnd.bind(this);

          this.el.addEventListener("model-loaded", this.onModelLoaded);

          window.addEventListener("touchstart", this.onTouchStart, { passive: true });
          window.addEventListener("touchmove",  this.onTouchMove,  { passive: true });
          window.addEventListener("touchend",   this.onTouchEnd,   { passive: true });
        },

        remove: function () {
          window.removeEventListener("touchstart", this.onTouchStart);
          window.removeEventListener("touchmove",  this.onTouchMove);
          window.removeEventListener("touchend",   this.onTouchEnd);
        },

        clamp: function (v, min, max) {
          return Math.max(min, Math.min(max, v));
        },

        touchDistance: function (t1, t2) {
          const dx = t2.clientX - t1.clientX;
          const dy = t2.clientY - t1.clientY;
          return Math.hypot(dx, dy);
        },

        onModelLoaded: function () {
          this.modelRoot = this.el.getObject3D("mesh");
          if (!this.modelRoot) return;

          this.piezaH = this.modelRoot.getObjectByName(this.data.horizontalNode);
          this.piezaV = this.modelRoot.getObjectByName(this.data.verticalNode);

          if (!this.piezaH || !this.piezaV) {
            console.warn("No encontré nodos. Revisa nombres:", {
              horizontalNode: this.data.horizontalNode,
              verticalNode: this.data.verticalNode,
              foundH: !!this.piezaH,
              foundV: !!this.piezaV
            });

            // Debug: imprime nombres disponibles
            this.modelRoot.traverse((o) => { if (o.name) console.log("NODE:", o.name); });
          }
        },

        pickPart: function (clientX, clientY) {
          const sceneEl = this.el.sceneEl;
          const camera = sceneEl.camera;
          const renderer = sceneEl.renderer;
          if (!camera || !renderer || !this.modelRoot) return null;

          const rect = renderer.domElement.getBoundingClientRect();
          this.ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
          this.ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);

          this.raycaster.setFromCamera(this.ndc, camera);
          const hits = this.raycaster.intersectObject(this.modelRoot, true);
          if (!hits.length) return null;

          const hitObj = hits[0].object;

          const isInside = (obj, ancestor) => {
            let o = obj;
            while (o) {
              if (o === ancestor) return true;
              o = o.parent;
            }
            return false;
          };

          if (this.piezaH && isInside(hitObj, this.piezaH)) return "H";
          if (this.piezaV && isInside(hitObj, this.piezaV)) return "V";
          return null;
        },

        onTouchStart: function (event) {
          if (!this.modelRoot) return;

          if (event.touches.length === 2) {
            // Pinch zoom del modelo completo
            this.pinching = true;
            this.dragging = false;
            this.prevPinchDist = this.touchDistance(event.touches[0], event.touches[1]);
            return;
          }

          if (event.touches.length === 1) {
            this.pinching = false;
            this.dragging = true;

            const t = event.touches[0];
            this.prevX = t.clientX;
            this.prevY = t.clientY;

            // Selecciona pieza tocada
            const picked = this.pickPart(t.clientX, t.clientY);
            this.selected = picked; // "H" | "V" | null
          }
        },

        onTouchMove: function (event) {
          if (!this.modelRoot) return;

          // Pinch zoom
          if (this.pinching && event.touches.length === 2) {
            const dist = this.touchDistance(event.touches[0], event.touches[1]);
            const delta = dist - this.prevPinchDist;
            this.prevPinchDist = dist;

            const factor = 1 + (delta * this.data.zoomSpeed);

            const current = this.el.getAttribute("scale") || { x: 0.5, y: 0.5, z: 0.5 };
            const next = {
              x: this.clamp(current.x * factor, this.data.minScale, this.data.maxScale),
              y: this.clamp(current.y * factor, this.data.minScale, this.data.maxScale),
              z: this.clamp(current.z * factor, this.data.minScale, this.data.maxScale),
            };
            this.el.setAttribute("scale", next);
            return;
          }

          // Drag 1 dedo: mueve SOLO la pieza seleccionada
          if (this.dragging && event.touches.length === 1 && this.selected) {
            const t = event.touches[0];
            const x = t.clientX;
            const y = t.clientY;

            const dx = x - this.prevX;
            const dy = y - this.prevY;

            this.prevX = x;
            this.prevY = y;

            if (this.selected === "H" && this.piezaH) {
              // pieza1: solo X
              this.piezaH.position.x += dx * this.data.moveSpeed;
            } else if (this.selected === "V" && this.piezaV) {
              // pieza2: solo Y (arriba en pantalla = +Y)
              this.piezaV.position.y += -dy * this.data.moveSpeed;
            }
          }
        },

        onTouchEnd: function (event) {
          if (event.touches.length < 2) this.pinching = false;
          if (event.touches.length === 0) {
            this.dragging = false;
            this.selected = null; // suelta selección al levantar
          }

          if (event.touches.length === 1) {
            const t = event.touches[0];
            this.prevX = t.clientX;
            this.prevY = t.clientY;
          }
        },
      });
    </script>
  </body>
</html>

