<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <style>
      html, body { margin: 0; overflow: hidden; }
      body { touch-action: none; }

      /* overlay: cuando est√° oculto no estorba */
      #ytOverlay { pointer-events: none; }
      #ytOverlay.show { display: flex !important; pointer-events: auto; }
    </style>
  </head>

  <body>
    <a-scene
      id="scene"
      mindar-image="imageTargetSrc: ./targets0.mind;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- Target 0: modelo -->
      <a-entity mindar-image-target="targetIndex: 0">
        <a-gltf-model
          id="modelo"
          src="./modcarro.glb"
          position="0 0 0"
          rotation="0 0 0"
          scale="5 5 5"
          gesture-controls="tapaName: tapa_v31; tapaAxis: x; tapaMaxDeg: 180; tapaDegPerPx: 0.5;"
        ></a-gltf-model>
      </a-entity>

      <!-- Target 1: solo para disparar el video -->
      <a-entity id="target1" mindar-image-target="targetIndex: 1"></a-entity>
    </a-scene>

    <!-- Overlay YouTube -->
    <div id="ytOverlay" style="
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.65);
      z-index: 9999;
    ">
      <div style="width: min(92vw, 900px); aspect-ratio: 16/9; background: #000; border-radius: 14px; overflow: hidden;">
        <iframe
          id="ytFrame"
          width="100%" height="100%"
          frameborder="0"
          allow="autoplay; encrypted-media; picture-in-picture"
          allowfullscreen
        ></iframe>
      </div>

      <button id="ytClose" style="
        position: fixed;
        top: 16px; right: 16px;
        font-size: 18px;
        padding: 10px 14px;
        border: 0;
        border-radius: 10px;
        cursor: pointer;
      ">Cerrar ‚úï</button>
    </div>

    <!-- Tu componente -->
    <script>
      AFRAME.registerComponent("gesture-controls", {
        schema: {
          zoomSpeed: { type: "number", default: 0.0025 },
          minScale:  { type: "number", default: 0.8 },
          maxScale:  { type: "number", default: 15.0 },

          rotateSpeed: { type: "number", default: 0.008 },
          minMovePx:   { type: "number", default: 1 },

          tapaName:     { type: "string", default: "tapa_v31" },
          tapaAxis:     { type: "string", default: "x" },
          tapaMinDeg:   { type: "number", default: 0 },
          tapaMaxDeg:   { type: "number", default: 180 },
          tapaDegPerPx: { type: "number", default: 0.5 }
        },

        init: function () {
          this.canvas = null;
          this.camera = null;
          this.pointers = new Map();

          this.isPinching = false;
          this.isRotating = false;

          this.draggingPart = null;
          this.tapaAngleDeg = 0;
          this.tapaStartAngleDeg = 0;

          this.tapaIntent = null;
          this.tapaAccumPx = 0;
          this.tapaLastX = 0;
          this.tapaLastY = 0;

          this.modelRoot = null;
          this.tapaObj = null;

          this.raycaster = new THREE.Raycaster();
          this.ndc = new THREE.Vector2();

          this.prevDist = 0;
          this.prevX = 0;

          this.onPointerDown = this.onPointerDown.bind(this);
          this.onPointerMove = this.onPointerMove.bind(this);
          this.onPointerUp   = this.onPointerUp.bind(this);

          this.el.addEventListener("model-loaded", () => {
            this.modelRoot = this.el.object3D;
            this.modelRoot.add(new THREE.AxesHelper(0.6));

            this.tapaObj = this.modelRoot.getObjectByName(this.data.tapaName);
            if (this.tapaObj) {
              this.tapaObj.add(new THREE.AxesHelper(0.3));
              console.log("‚úÖ Tapa encontrada:", this.data.tapaName);
            } else {
              console.warn("‚ö†Ô∏è No encontr√© la tapa con nombre:", this.data.tapaName);
            }

            console.log("‚úÖ model-loaded OK");
          });

          const waitForCanvas = () => {
            const scene = this.el.sceneEl;
            if (scene && scene.renderer && scene.renderer.domElement && scene.camera) {
              this.canvas = scene.renderer.domElement;
              this.camera = scene.camera;

              this.canvas.style.touchAction = "none";

              this.canvas.addEventListener("pointerdown", this.onPointerDown, { passive: false, capture: true });
              window.addEventListener("pointermove", this.onPointerMove, { passive: false, capture: true });
              window.addEventListener("pointerup", this.onPointerUp, { passive: false, capture: true });
              window.addEventListener("pointercancel", this.onPointerUp, { passive: false, capture: true });

              console.log("‚úÖ Pointer events activos");
            } else {
              setTimeout(waitForCanvas, 100);
            }
          };
          waitForCanvas();
        },

        clamp: function (v, min, max) { return Math.max(min, Math.min(max, v)); },

        _dist2Pointers: function () {
          const arr = Array.from(this.pointers.values());
          if (arr.length < 2) return 0;
          const dx = arr[1].x - arr[0].x;
          const dy = arr[1].y - arr[0].y;
          return Math.hypot(dx, dy);
        },

        _intersectModel: function (clientX, clientY) {
          if (!this.canvas || !this.camera || !this.modelRoot) return [];
          const rect = this.canvas.getBoundingClientRect();

          this.ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
          this.ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);

          this.modelRoot.updateMatrixWorld(true);
          this.raycaster.setFromCamera(this.ndc, this.camera);
          return this.raycaster.intersectObject(this.modelRoot, true);
        },

        _hitIsTapa: function (hitObj) {
          if (!this.tapaObj) return false;
          let o = hitObj;
          while (o) {
            if (o === this.tapaObj) return true;
            o = o.parent;
          }
          return false;
        },

        _applyTapaAngleDeg: function (deg) {
          if (!this.tapaObj) return;
          this.tapaAngleDeg = this.clamp(deg, this.data.tapaMinDeg, this.data.tapaMaxDeg);

          const rad = -THREE.MathUtils.degToRad(this.tapaAngleDeg); // invertido
          const axis = (this.data.tapaAxis || "x").toLowerCase();

          if (axis === "x") this.tapaObj.rotation.x = rad;
          else if (axis === "y") this.tapaObj.rotation.y = rad;
          else this.tapaObj.rotation.z = rad;
        },

        onPointerDown: function (e) {
          if (e.pointerType !== "touch") return;
          if (e.cancelable) e.preventDefault();
          try { e.target.setPointerCapture(e.pointerId); } catch (_) {}

          this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          if (this.pointers.size === 2) {
            this.isPinching = true;
            this.isRotating = false;
            this.draggingPart = null;
            this.prevDist = this._dist2Pointers();
            return;
          }

          if (this.pointers.size === 1) {
            const hits = this._intersectModel(e.clientX, e.clientY);
            const touchedTapa = hits.length > 0 && this._hitIsTapa(hits[0].object);

            if (touchedTapa) {
              this.draggingPart = "tapa";
              this.isRotating = false;
              this.isPinching = false;

              const mid = (this.data.tapaMinDeg + this.data.tapaMaxDeg) / 2;
              this.tapaIntent = (this.tapaAngleDeg >= mid) ? "close" : "open";

              this.tapaStartAngleDeg = this.tapaAngleDeg;
              this.tapaAccumPx = 0;
              this.tapaLastX = e.clientX;
              this.tapaLastY = e.clientY;
              return;
            }

            this.draggingPart = null;
            this.isRotating = true;
            this.isPinching = false;
            this.prevX = e.clientX;
          }
        },

        onPointerMove: function (e) {
          if (e.pointerType !== "touch") return;
          if (!this.pointers.has(e.pointerId)) return;
          if (e.cancelable) e.preventDefault();

          this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          if (this.isPinching && this.pointers.size === 2) {
            const dist = this._dist2Pointers();
            const delta = dist - this.prevDist;
            this.prevDist = dist;

            const factor = 1 + (delta * this.data.zoomSpeed);
            const s = this.el.getAttribute("scale") || { x: 1, y: 1, z: 1 };

            const nx = this.clamp(s.x * factor, this.data.minScale, this.data.maxScale);
            const ny = this.clamp(s.y * factor, this.data.minScale, this.data.maxScale);
            const nz = this.clamp(s.z * factor, this.data.minScale, this.data.maxScale);

            this.el.setAttribute("scale", { x: nx, y: ny, z: nz });
            return;
          }

          if (this.draggingPart === "tapa" && this.pointers.size === 1) {
            const dx = e.clientX - this.tapaLastX;
            const dy = e.clientY - this.tapaLastY;

            this.tapaLastX = e.clientX;
            this.tapaLastY = e.clientY;

            const step = Math.hypot(dx, dy);
            if (step < 0.5) return;

            const mid = (this.data.tapaMinDeg + this.data.tapaMaxDeg) / 2;

            if (this.tapaIntent === "open") {
              this.tapaAccumPx += step;
              const deltaDeg = this.tapaAccumPx * this.data.tapaDegPerPx;
              this._applyTapaAngleDeg(this.tapaStartAngleDeg + deltaDeg);
              return;
            }

            const inTopHalf = this.tapaAngleDeg > mid;
            const expectsUp = inTopHalf;
            const goingUp = dy < 0;
            const goingDown = dy > 0;

            let advancePx = 0;
            if (expectsUp && goingUp) advancePx = step;
            if (!expectsUp && goingDown) advancePx = step;
            if (advancePx <= 0) return;

            this.tapaAccumPx += advancePx;

            const deltaDeg = this.tapaAccumPx * this.data.tapaDegPerPx;
            const candidate = this.tapaStartAngleDeg - deltaDeg;

            if (this.tapaStartAngleDeg > mid && candidate <= mid) {
              this._applyTapaAngleDeg(mid);
              this.tapaStartAngleDeg = mid;
              this.tapaAccumPx = 0;
              return;
            }

            this._applyTapaAngleDeg(candidate);
            return;
          }

          if (this.isRotating && this.pointers.size === 1) {
            const dx = e.clientX - this.prevX;
            if (Math.abs(dx) < this.data.minMovePx) return;
            this.prevX = e.clientX;
            this.el.object3D.rotation.y += dx * this.data.rotateSpeed;
          }
        },

        onPointerUp: function (e) {
          if (e.pointerType !== "touch") return;
          if (e.cancelable) e.preventDefault();

          this.pointers.delete(e.pointerId);

          if (this.pointers.size === 2) {
            this.isPinching = true;
            this.isRotating = false;
            this.draggingPart = null;
            this.prevDist = this._dist2Pointers();
            return;
          }

          this.isPinching = false;
          this.isRotating = false;
          this.draggingPart = null;
          this.prevDist = 0;

          this.tapaAccumPx = 0;
          this.tapaIntent = null;
        }
      });
    </script>

    <!-- Script YouTube: mejor engancharlo cuando la escena est√© lista -->
    <script>
      const scene = document.querySelector("#scene");

      scene.addEventListener("loaded", () => {
        const target1 = document.querySelector("#target1");
        const overlay = document.getElementById("ytOverlay");
        const frame = document.getElementById("ytFrame");
        const closeBtn = document.getElementById("ytClose");

        const VIDEO_ID = "0xKeIFzrVuo";
        const YT_URL = `https://www.youtube-nocookie.com/embed/${VIDEO_ID}?autoplay=1&playsinline=1&rel=0`;

        const openYT = () => {
          overlay.classList.add("show");
          frame.src = YT_URL;
        };

        const closeYT = () => {
          frame.src = "";
          overlay.classList.remove("show");
          overlay.style.display = "none"; // por si acaso
        };

        closeBtn.addEventListener("click", closeYT);
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) closeYT();
        });

        // mostrar/ocultar overlay correctamente
        const showOverlay = () => {
          overlay.style.display = "flex";
          openYT();
        };

        target1.addEventListener("targetFound", showOverlay);
        target1.addEventListener("targetLost", closeYT);
      });
    </script>
    <script>
      const scene = document.querySelector("#scene");
      scene.addEventListener("loaded", () => {
        const target1 = document.querySelector("#target1");
    
        console.log("‚úÖ scene loaded, target1:", target1);
    
        target1.addEventListener("targetFound", () => {
          console.log("üéØ targetIndex 1 FOUND");
          document.getElementById("ytOverlay").style.display = "flex";
          document.getElementById("ytFrame").src =
            "https://www.youtube-nocookie.com/embed/0xKeIFzrVuo?autoplay=1&playsinline=1&rel=0";
        });
    
        target1.addEventListener("targetLost", () => {
          console.log("‚ùå targetIndex 1 LOST");
          document.getElementById("ytFrame").src = "";
          document.getElementById("ytOverlay").style.display = "none";
        });
      });
    </script>
  </body>
</html>




