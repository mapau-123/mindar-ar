<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>

  <body style="margin:0; overflow:hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-gltf-model
          id="modelo"
          src="./carromodelo0.glb"
          scale="2.5 2.5 2.5"
          simple-rotate-zoom="tapaMaxOpen: 180; wheelRange: 0.20; wheelMoveSpeed: 0.0025; globalRotateSpeed: 1.2;"
        ></a-gltf-model>
      </a-entity>
    </a-scene>

    <script>
      // =========================
      // Estado global de nodos
      // =========================
      window.NODES = {
        cuerpo: null,
        rueda1: null,
        rueda2: null,
        tapa: null,

        // tapa: quaternion + eje local
        tapaBaseQuat: null,
        tapaOpenDeg: 0,
        tapaDir: 1,          // pon -1 si abre al revés
        tapaLocalAxis: "x",  // "x" | "y" | "z"
      };

      AFRAME.registerComponent("simple-rotate-zoom", {
        schema: {
          // GLOBAL (2 dedos)
          zoomSpeed:   { type: "number", default: 0.002 },
          minScale:    { type: "number", default: 0.8 },
          maxScale:    { type: "number", default: 8.0 },
          globalRotateSpeed: { type: "number", default: 1.0 },

          // TAPA (1 dedo)
          tapaSwipeSpeed: { type: "number", default: 0.25 },
          tapaMaxOpen:    { type: "number", default: 180 },

          // RUEDAS (1 dedo)
          wheelMoveSpeed: { type: "number", default: 0.0015 },
          wheelRange:     { type: "number", default: 0.15 },

          // CUERPO (1 dedo)
          cuerpoRotateSpeed: { type: "number", default: 0.25 }
        },

        init: function () {
          this.mode = null;
          this.prevX = 0;
          this.prevY = 0;
          this.prevPinchDist = 0;
          this.prevTwistAngle = 0;
          this.selected = null;

          this.raycaster = new THREE.Raycaster();
          this.ndc = new THREE.Vector2();
          this.modelMeshRoot = null;

          this.onTouchStart = this.onTouchStart.bind(this);
          this.onTouchMove  = this.onTouchMove.bind(this);
          this.onTouchEnd   = this.onTouchEnd.bind(this);

          // ✅ Captura del GLB dentro del lifecycle correcto
          this.el.addEventListener("model-loaded", () => {
            this.modelMeshRoot = this.el.getObject3D("mesh");

            const root = this.el.object3D;

            // nombres de tus nodos (ajústalos si cambiaron en el nuevo GLB)
            NODES.cuerpo = root.getObjectByName("cuerpo_v11");
            NODES.rueda1 = root.getObjectByName("rueda1_v11");
            NODES.rueda2 = root.getObjectByName("rueda2_v11");
            NODES.tapa   = root.getObjectByName("tapa_v11");

            if (NODES.tapa) {
              // muestra ejes del nodo tapa
              NODES.tapa.add(new THREE.AxesHelper(0.2));
            
              // muestra una bolita EXACTAMENTE en el origen local (pivot real)
              const s = new THREE.Mesh(
                new THREE.SphereGeometry(0.01, 12, 12),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
              );
              NODES.tapa.add(s);
              s.position.set(0, 0, 0);
            
              console.log("tapa pivot local:", NODES.tapa.position);
            }

            console.log("=== NODOS LISTOS ===");
            console.log("cuerpo:", NODES.cuerpo?.name);
            console.log("rueda1:", NODES.rueda1?.name);
            console.log("rueda2:", NODES.rueda2?.name);
            console.log("tapa:",   NODES.tapa?.name);
            console.log("tapaLocalAxis:", NODES.tapaLocalAxis, "tapaDir:", NODES.tapaDir);
          });

          // ✅ Si el GLB falla, lo verás
          this.el.addEventListener("model-error", (e) => {
            console.error("❌ Error cargando GLB:", e?.detail || e);
          });

          // Eventos touch
          const waitForCanvas = () => {
            if (this.el.sceneEl && this.el.sceneEl.canvas) {
              const canvas = this.el.sceneEl.canvas;
              canvas.addEventListener("touchstart", this.onTouchStart, { passive: true });
              canvas.addEventListener("touchmove",  this.onTouchMove,  { passive: false });
              canvas.addEventListener("touchend",   this.onTouchEnd,   { passive: true });
            } else {
              setTimeout(waitForCanvas, 100);
            }
          };
          waitForCanvas();
        },

        clamp: function (v, min, max) {
          return Math.max(min, Math.min(max, v));
        },

        touchDistance: function (t1, t2) {
          const dx = t2.clientX - t1.clientX;
          const dy = t2.clientY - t1.clientY;
          return Math.hypot(dx, dy);
        },

        twistAngleRad: function (t1, t2) {
          const dx = t2.clientX - t1.clientX;
          const dy = t2.clientY - t1.clientY;
          return Math.atan2(dy, dx);
        },

        pickPart: function (clientX, clientY) {
          if (!this.modelMeshRoot || !window.NODES) return null;

          const sceneEl = this.el.sceneEl;
          const camera = sceneEl.camera;
          const renderer = sceneEl.renderer;
          if (!camera || !renderer) return null;

          const rect = renderer.domElement.getBoundingClientRect();
          this.ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
          this.ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);

          this.raycaster.setFromCamera(this.ndc, camera);
          const hits = this.raycaster.intersectObject(this.modelMeshRoot, true);
          if (!hits.length) return null;

          const hitObj = hits[0].object;

          const isDescendantOf = (obj, ancestor) => {
            let o = obj;
            while (o) {
              if (o === ancestor) return true;
              o = o.parent;
            }
            return false;
          };

          if (NODES.tapa   && isDescendantOf(hitObj, NODES.tapa))   return "TAPA";
          if (NODES.rueda1 && isDescendantOf(hitObj, NODES.rueda1)) return "W1";
          if (NODES.rueda2 && isDescendantOf(hitObj, NODES.rueda2)) return "W2";
          if (NODES.cuerpo && isDescendantOf(hitObj, NODES.cuerpo)) return "CUERPO";

          return null;
        },

        onTouchStart: function (event) {
          if (event.touches.length === 2) {
            this.mode = "GLOBAL";
            this.selected = null;

            const t1 = event.touches[0];
            const t2 = event.touches[1];

            this.prevPinchDist = this.touchDistance(t1, t2);
            this.prevTwistAngle = this.twistAngleRad(t1, t2);
            return;
          }

          if (event.touches.length === 1) {
            this.mode = "PART";
            const t = event.touches[0];
            this.prevX = t.clientX;
            this.prevY = t.clientY;

            this.selected = this.pickPart(t.clientX, t.clientY);

            if (window.NODES) {
              if (NODES.rueda1 && NODES.rueda1BaseX === undefined) NODES.rueda1BaseX = NODES.rueda1.position.x;
              if (NODES.rueda2 && NODES.rueda2BaseX === undefined) NODES.rueda2BaseX = NODES.rueda2.position.x;
              if (NODES.cuerpo && NODES.cuerpoBaseRotY === undefined) {
                NODES.cuerpoBaseRotY = THREE.MathUtils.radToDeg(NODES.cuerpo.rotation.y);
                NODES.cuerpoRotY = NODES.cuerpoBaseRotY;
              }
            }
          }
        },

        onTouchMove: function (event) {
          if (event.cancelable) event.preventDefault();

          // GLOBAL: 2 dedos (zoom + twist rota modelo completo)
          if (this.mode === "GLOBAL" && event.touches.length === 2) {
            const t1 = event.touches[0];
            const t2 = event.touches[1];

            const dist = this.touchDistance(t1, t2);
            const deltaDist = dist - this.prevPinchDist;
            this.prevPinchDist = dist;

            const factor = 1 + (deltaDist * this.data.zoomSpeed);
            const current = this.el.getAttribute("scale") || { x: 1, y: 1, z: 1 };
            this.el.setAttribute("scale", {
              x: this.clamp(current.x * factor, this.data.minScale, this.data.maxScale),
              y: this.clamp(current.y * factor, this.data.minScale, this.data.maxScale),
              z: this.clamp(current.z * factor, this.data.minScale, this.data.maxScale),
            });

            const ang = this.twistAngleRad(t1, t2);
            let dAng = ang - this.prevTwistAngle;
            this.prevTwistAngle = ang;

            if (dAng > Math.PI) dAng -= 2 * Math.PI;
            if (dAng < -Math.PI) dAng += 2 * Math.PI;

            const rot = this.el.getAttribute("rotation") || { x: 0, y: 0, z: 0 };
            this.el.setAttribute("rotation", {
              x: rot.x,
              y: rot.y + THREE.MathUtils.radToDeg(dAng) * this.data.globalRotateSpeed,
              z: rot.z
            });

            return;
          }

          // PARTES: 1 dedo
          if (this.mode === "PART" && event.touches.length === 1) {
            const t = event.touches[0];
            const x = t.clientX;
            const y = t.clientY;

            const dx = x - this.prevX;
            const dy = y - this.prevY;

            this.prevX = x;
            this.prevY = y;

            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);

            // ✅ TAPA: quaternion en eje LOCAL (x/y/z)
            if (this.selected === "TAPA" && window.NODES && NODES.tapa && NODES.tapaBaseQuat) {
              const deltaOpen = (-dy) * this.data.tapaSwipeSpeed;
              NODES.tapaOpenDeg = this.clamp(NODES.tapaOpenDeg + deltaOpen, 0, this.data.tapaMaxOpen);

              let axis = new THREE.Vector3(1, 0, 0);
              if (NODES.tapaLocalAxis === "y") axis.set(0, 1, 0);
              if (NODES.tapaLocalAxis === "z") axis.set(0, 0, 1);

              const angleRad = THREE.MathUtils.degToRad(NODES.tapaDir * NODES.tapaOpenDeg);
              const q = new THREE.Quaternion().setFromAxisAngle(axis, angleRad);

              NODES.tapa.quaternion.copy(NODES.tapaBaseQuat).multiply(q);
              return;
            }

            // RUEDA 1: solo izquierda
            if (this.selected === "W1" && window.NODES && NODES.rueda1 && absDx >= absDy) {
              const onlyLeft = Math.min(0, dx) * this.data.wheelMoveSpeed;
              const minX = NODES.rueda1BaseX - this.data.wheelRange;
              const maxX = NODES.rueda1BaseX;
              NODES.rueda1.position.x = this.clamp(NODES.rueda1.position.x + onlyLeft, minX, maxX);
              return;
            }

            // RUEDA 2: solo derecha
            if (this.selected === "W2" && window.NODES && NODES.rueda2 && absDx >= absDy) {
              const onlyRight = Math.max(0, dx) * this.data.wheelMoveSpeed;
              const minX = NODES.rueda2BaseX;
              const maxX = NODES.rueda2BaseX + this.data.wheelRange;
              NODES.rueda2.position.x = this.clamp(NODES.rueda2.position.x + onlyRight, minX, maxX);
              return;
            }

            // CUERPO: opcional
            if (this.selected === "CUERPO" && window.NODES && NODES.cuerpo && absDx >= absDy) {
              const deltaDeg = dx * this.data.cuerpoRotateSpeed;
              NODES.cuerpoRotY = (NODES.cuerpoRotY || 0) + deltaDeg;
              NODES.cuerpo.rotation.y = THREE.MathUtils.degToRad(NODES.cuerpoRotY);
              return;
            }
          }
        },

        onTouchEnd: function (event) {
          if (event.touches.length === 0) {
            this.mode = null;
            this.selected = null;
          } else {
            this.mode = null;
          }
        }
      });
    </script>
  </body>
</html>



