<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <style>
      html, body { margin: 0; overflow: hidden; }
      body { touch-action: none; } /* clave */
    </style>
  </head>

  <body>
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-gltf-model
          id="modelo"
          src="./modcarro.glb"
          position="0 0 0"
          rotation="0 0 0"
          scale="5 5 5"
          gesture-controls
        ></a-gltf-model>
      </a-entity>
    </a-scene>

    <script>
      AFRAME.registerComponent("gesture-controls", {
        schema: {
          // Pinch zoom
          zoomSpeed: { type: "number", default: 0.0025 },
          minScale:  { type: "number", default: 0.8 },
          maxScale:  { type: "number", default: 15.0 },

          // Rotación 1 dedo
          rotateSpeed: { type: "number", default: 0.008 }, // radianes por pixel aprox
          minMovePx:   { type: "number", default: 1 }
        },

        init: function () {
          this.canvas = null;

          // pointers activos: id -> {x,y}
          this.pointers = new Map();

          // pinch
          this.isPinching = false;
          this.prevDist = 0;

          // rotate
          this.isRotating = false;
          this.prevX = 0;

          this.onPointerDown = this.onPointerDown.bind(this);
          this.onPointerMove = this.onPointerMove.bind(this);
          this.onPointerUp   = this.onPointerUp.bind(this);

          // Ejes al cargar el modelo
          this.el.addEventListener("model-loaded", () => {
            const root = this.el.object3D;
            root.add(new THREE.AxesHelper(0.6));

            const tapa = root.getObjectByName("tapa_v31");
            if (tapa) tapa.add(new THREE.AxesHelper(0.3));

            console.log("✅ model-loaded OK");
          });

          this.el.addEventListener("model-error", (e) => {
            console.error("❌ Error cargando GLB:", e?.detail || e);
          });

          // Esperar el canvas real del renderer
          const waitForCanvas = () => {
            const scene = this.el.sceneEl;
            if (scene && scene.renderer && scene.renderer.domElement) {
              this.canvas = scene.renderer.domElement;

              // MUY importante para que no haga scroll/zoom nativo
              this.canvas.style.touchAction = "none";

              // listeners (usar capture ayuda a que no se los “robe” otra capa)
              this.canvas.addEventListener("pointerdown", this.onPointerDown, { passive: false, capture: true });
              window.addEventListener("pointermove", this.onPointerMove, { passive: false, capture: true });
              window.addEventListener("pointerup", this.onPointerUp, { passive: false, capture: true });
              window.addEventListener("pointercancel", this.onPointerUp, { passive: false, capture: true });

              console.log("✅ Pointer events activos");
            } else {
              setTimeout(waitForCanvas, 100);
            }
          };
          waitForCanvas();
        },

        remove: function () {
          if (!this.canvas) return;
          this.canvas.removeEventListener("pointerdown", this.onPointerDown, { capture: true });
          window.removeEventListener("pointermove", this.onPointerMove, { capture: true });
          window.removeEventListener("pointerup", this.onPointerUp, { capture: true });
          window.removeEventListener("pointercancel", this.onPointerUp, { capture: true });
        },

        clamp: function (v, min, max) {
          return Math.max(min, Math.min(max, v));
        },

        _dist2Pointers: function () {
          const arr = Array.from(this.pointers.values());
          if (arr.length < 2) return 0;
          const dx = arr[1].x - arr[0].x;
          const dy = arr[1].y - arr[0].y;
          return Math.hypot(dx, dy);
        },

        onPointerDown: function (e) {
          // solo gestos táctiles (si quieres también mouse, quita esta línea)
          if (e.pointerType !== "touch") return;

          if (e.cancelable) e.preventDefault();

          // capturar el pointer para que no se pierda si sale del canvas
          try { e.target.setPointerCapture(e.pointerId); } catch (_) {}

          this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          if (this.pointers.size === 1) {
            // 1 dedo -> rotar
            this.isRotating = true;
            this.isPinching = false;
            this.prevX = e.clientX;
          } else if (this.pointers.size === 2) {
            // 2 dedos -> pinch (siempre permitido)
            this.isPinching = true;
            this.isRotating = false;
            this.prevDist = this._dist2Pointers();
          } else {
            // 3+ dedos: ignorar
            this.isPinching = false;
            this.isRotating = false;
          }
        },

        onPointerMove: function (e) {
          if (e.pointerType !== "touch") return;
          if (!this.pointers.has(e.pointerId)) return;

          if (e.cancelable) e.preventDefault();

          this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          // Pinch
          if (this.isPinching && this.pointers.size === 2) {
            const dist = this._dist2Pointers();
            const delta = dist - this.prevDist;
            this.prevDist = dist;

            const factor = 1 + (delta * this.data.zoomSpeed);

            const s = this.el.getAttribute("scale") || { x: 1, y: 1, z: 1 };
            const nx = this.clamp(s.x * factor, this.data.minScale, this.data.maxScale);
            const ny = this.clamp(s.y * factor, this.data.minScale, this.data.maxScale);
            const nz = this.clamp(s.z * factor, this.data.minScale, this.data.maxScale);

            this.el.setAttribute("scale", { x: nx, y: ny, z: nz });
            return;
          }

          // Rotación (solo Y)
          if (this.isRotating && this.pointers.size === 1) {
            const dx = e.clientX - this.prevX;
            if (Math.abs(dx) < this.data.minMovePx) return;
            this.prevX = e.clientX;

            // aplicar directo al object3D (en radianes)
            this.el.object3D.rotation.y += dx * this.data.rotateSpeed;
          }
        },

        onPointerUp: function (e) {
          if (e.pointerType !== "touch") return;
          if (e.cancelable) e.preventDefault();

          this.pointers.delete(e.pointerId);

          if (this.pointers.size === 2) {
            this.isPinching = true;
            this.isRotating = false;
            this.prevDist = this._dist2Pointers();
          } else if (this.pointers.size === 1) {
            this.isRotating = true;
            this.isPinching = false;
            const only = Array.from(this.pointers.values())[0];
            this.prevX = only.x;
          } else {
            this.isRotating = false;
            this.isPinching = false;
            this.prevDist = 0;
          }
        }
      });
    </script>
  </body>
</html>
