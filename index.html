<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>

  <body style="margin:0; overflow:hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
      renderer="colorManagement: true; physicallyCorrectLights: true"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- TARGET -->
      <a-entity id="target0" mindar-image-target="targetIndex: 0">

        <!-- PIVOT: aquí se rota el modelo completo -->
        <a-entity id="pivot" carrito-controls="
          tapaNode: 'tapa v1:1';
          wheel1Node: 'rueda1 v1:1';
          wheel2Node: 'rueda2 v1:1';

          rotateSpeed: 0.5;
          zoomSpeed: 0.002;
          minScale: 1.0;
          maxScale: 10.0;

          wheelMoveSpeed: 0.002;
          wheelRange: 0.15;

          tapaRotateSpeed: 0.3;
          tapaMinX: -10;
          tapaMaxX: 85;
        ">
          <a-gltf-model
            id="modelo"
            src="./carromodelo2.glb"
            position="0 0 0"
            rotation="0 0 0"
            scale="2.5 2.5 2.5"
          ></a-gltf-model>

          <!-- Ejes de referencia -->
          <a-entity position="0 0 0">
            <a-entity line="start: 0 0 0; end: 0.2 0 0; color: red"></a-entity>
            <a-entity line="start: 0 0 0; end: 0 0.2 0; color: green"></a-entity>
            <a-entity line="start: 0 0 0; end: 0 0 0.2; color: blue"></a-entity>
          </a-entity>
        </a-entity>

      </a-entity>
    </a-scene>

    <script>
      AFRAME.registerComponent("carrito-controls", {
        schema: {
          tapaNode:   { type: "string", default: "" },
          wheel1Node: { type: "string", default: "" },
          wheel2Node: { type: "string", default: "" },

          rotateSpeed: { type: "number", default: 0.5 },

          zoomSpeed: { type: "number", default: 0.002 },
          minScale:  { type: "number", default: 1.0 },
          maxScale:  { type: "number", default: 10.0 },

          wheelMoveSpeed: { type: "number", default: 0.002 },
          wheelRange:     { type: "number", default: 0.15 },

          // tapa en grados (X)
          tapaRotateSpeed: { type: "number", default: 0.3 },
          tapaMinX:        { type: "number", default: -10 },
          tapaMaxX:        { type: "number", default: 85 },
        },

        init: function () {
          // El componente está en el PIVOT (<a-entity id="pivot">)
          // El target entity es el padre del pivot (mindar-image-target)
          this.targetEl = this.el.parentEl;

          this.modelRoot = null;
          this.tapa = null;
          this.wheel1 = null;
          this.wheel2 = null;

          this.baseWheel1X = 0;
          this.baseWheel2X = 0;

          this.selected = null; // "TAPA" | "W1" | "W2" | null
          this.dragging = false;
          this.pinching = false;
          this.enabled = false; // solo cuando el target está visible

          this.prevX = 0;
          this.prevY = 0;
          this.prevPinchDist = 0;

          this.raycaster = new THREE.Raycaster();
          this.ndc = new THREE.Vector2();

          // rotaremos el pivot (this.el.object3D)
          this.rotTarget = this.el.object3D;

          this.onModelLoaded = this.onModelLoaded.bind(this);
          this.onTouchStart  = this.onTouchStart.bind(this);
          this.onTouchMove   = this.onTouchMove.bind(this);
          this.onTouchEnd    = this.onTouchEnd.bind(this);
          this.bindCanvasEvents = this.bindCanvasEvents.bind(this);

          // Target found/lost (escucha en el entity del target)
          if (this.targetEl) {
            this.targetEl.addEventListener("targetFound", () => (this.enabled = true));
            this.targetEl.addEventListener("targetLost",  () => {
              this.enabled = false;
              this.dragging = false;
              this.pinching = false;
              this.selected = null;
            });
          }

          // Espera a que el canvas exista
          this.el.sceneEl.addEventListener("render-target-loaded", this.bindCanvasEvents);

          // El gltf-model está dentro del pivot: lo buscamos y escuchamos su "model-loaded"
          this.gltfEl = this.el.querySelector("a-gltf-model");
          if (this.gltfEl) {
            this.gltfEl.addEventListener("model-loaded", this.onModelLoaded);
          } else {
            console.warn("No encontré el <a-gltf-model> dentro del pivot.");
          }
        },

        remove: function () {
          const canvas = this.el.sceneEl && this.el.sceneEl.canvas;
          if (canvas) {
            canvas.removeEventListener("touchstart", this.onTouchStart);
            canvas.removeEventListener("touchmove",  this.onTouchMove);
            canvas.removeEventListener("touchend",   this.onTouchEnd);
          }
          this.el.sceneEl.removeEventListener("render-target-loaded", this.bindCanvasEvents);

          if (this.gltfEl) this.gltfEl.removeEventListener("model-loaded", this.onModelLoaded);
        },

        bindCanvasEvents: function () {
          const canvas = this.el.sceneEl && this.el.sceneEl.canvas;
          if (!canvas) return;

          // Importante: touchmove passive:false para poder preventDefault en pinch
          canvas.addEventListener("touchstart", this.onTouchStart, { passive: true });
          canvas.addEventListener("touchmove",  this.onTouchMove,  { passive: false });
          canvas.addEventListener("touchend",   this.onTouchEnd,   { passive: true });
        },

        clamp: function (v, min, max) {
          return Math.max(min, Math.min(max, v));
        },

        touchDistance: function (t1, t2) {
          const dx = t2.clientX - t1.clientX;
          const dy = t2.clientY - t1.clientY;
          return Math.hypot(dx, dy);
        },

        onModelLoaded: function () {
          // Importante: el mesh del gltf está en gltfEl
          this.modelRoot = this.gltfEl.getObject3D("mesh");
          if (!this.modelRoot) return;

          // Log de nodos para que confirmes nombres exactos
          console.log("=== NODOS DEL GLB ===");
          this.modelRoot.traverse((o) => { if (o.name) console.log("NODE:", o.name); });

          this.tapa   = this.modelRoot.getObjectByName(this.data.tapaNode);
          this.wheel1 = this.modelRoot.getObjectByName(this.data.wheel1Node);
          this.wheel2 = this.modelRoot.getObjectByName(this.data.wheel2Node);

          if (this.wheel1) this.baseWheel1X = this.wheel1.position.x;
          if (this.wheel2) this.baseWheel2X = this.wheel2.position.x;

          if (!this.tapa || !this.wheel1 || !this.wheel2) {
            console.warn("No encontré uno o más nodos. Revisa nombres exactos:", {
              tapaNode: this.data.tapaNode,
              whe






