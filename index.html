<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <style>
      html, body { margin: 0; overflow: hidden; }
      body { touch-action: none; }
    </style>
  </head>

  <body>
    <a-scene
      mindar-image="imageTargetSrc: ./targets2.mind;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      
      <a-entity mindar-image-target="targetIndex: 0">
        <a-gltf-model
          id="modelo"
          src="./modcarro.glb"
          position="0 0 0"
          rotation="0 0 0"
          scale="5 5 5"
          gesture-controls="tapaName: tapa_v31; tapaAxis: x; tapaMaxDeg: 180; tapaDegPerPx: 0.5;"
        ></a-gltf-model>
      </a-entity>
    </a-scene>

    <script>
      AFRAME.registerComponent("gesture-controls", {
        schema: {
          // Pinch zoom
          zoomSpeed: { type: "number", default: 0.0025 },
          minScale:  { type: "number", default: 0.8 },
          maxScale:  { type: "number", default: 15.0 },

          // Rotación global (1 dedo)
          rotateSpeed: { type: "number", default: 0.008 }, // rad/pixel
          minMovePx:   { type: "number", default: 1 },

          // Tapa interactiva
          tapaName:     { type: "string", default: "tapa_v31" },
          tapaAxis:     { type: "string", default: "x" },   // "x" | "y" | "z"
          tapaMinDeg:   { type: "number", default: 0 },
          tapaMaxDeg:   { type: "number", default: 180 },
          tapaDegPerPx: { type: "number", default: 0.5 }    // grados por pixel
        },

        init: function () {
          this.canvas = null;
          this.camera = null;

          // pointers activos: id -> {x,y}
          this.pointers = new Map();

          // estados
          this.isPinching = false;
          this.isRotating = false;

          // interacción tapa
          this.draggingPart = null; // "tapa" | null
          this.tapaAngleDeg = 0;
          this.tapaStartAngleDeg = 0;

          // drag natural
          this.tapaIntent = null; // "open" | "close"
          this.tapaAccumPx = 0;
          this.tapaLastX = 0;
          this.tapaLastY = 0;

          // refs THREE
          this.modelRoot = null;
          this.tapaObj = null;

          // raycast
          this.raycaster = new THREE.Raycaster();
          this.ndc = new THREE.Vector2();

          // pinch/rotate vars
          this.prevDist = 0;
          this.prevX = 0;

          this.onPointerDown = this.onPointerDown.bind(this);
          this.onPointerMove = this.onPointerMove.bind(this);
          this.onPointerUp   = this.onPointerUp.bind(this);

          this.el.addEventListener("model-loaded", () => {
            this.modelRoot = this.el.object3D;
            this.modelRoot.add(new THREE.AxesHelper(0.6));

            this.tapaObj = this.modelRoot.getObjectByName(this.data.tapaName);
            if (this.tapaObj) {
              this.tapaObj.add(new THREE.AxesHelper(0.3));
              console.log("✅ Tapa encontrada:", this.data.tapaName);
            } else {
              console.warn("⚠️ No encontré la tapa con nombre:", this.data.tapaName);
            }

            console.log("✅ model-loaded OK");
          });

          this.el.addEventListener("model-error", (e) => {
            console.error("❌ Error cargando GLB:", e?.detail || e);
          });

          const waitForCanvas = () => {
            const scene = this.el.sceneEl;
            if (scene && scene.renderer && scene.renderer.domElement && scene.camera) {
              this.canvas = scene.renderer.domElement;
              this.camera = scene.camera;

              this.canvas.style.touchAction = "none";

              this.canvas.addEventListener("pointerdown", this.onPointerDown, { passive: false, capture: true });
              window.addEventListener("pointermove", this.onPointerMove, { passive: false, capture: true });
              window.addEventListener("pointerup", this.onPointerUp, { passive: false, capture: true });
              window.addEventListener("pointercancel", this.onPointerUp, { passive: false, capture: true });

              console.log("✅ Pointer events activos");
            } else {
              setTimeout(waitForCanvas, 100);
            }
          };
          waitForCanvas();
        },

        clamp: function (v, min, max) {
          return Math.max(min, Math.min(max, v));
        },

        _dist2Pointers: function () {
          const arr = Array.from(this.pointers.values());
          if (arr.length < 2) return 0;
          const dx = arr[1].x - arr[0].x;
          const dy = arr[1].y - arr[0].y;
          return Math.hypot(dx, dy);
        },

        _intersectModel: function (clientX, clientY) {
          if (!this.canvas || !this.camera || !this.modelRoot) return [];
          const rect = this.canvas.getBoundingClientRect();

          this.ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
          this.ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);

          this.modelRoot.updateMatrixWorld(true);
          this.raycaster.setFromCamera(this.ndc, this.camera);

          return this.raycaster.intersectObject(this.modelRoot, true);
        },

        _hitIsTapa: function (hitObj) {
          if (!this.tapaObj) return false;
          let o = hitObj;
          while (o) {
            if (o === this.tapaObj) return true;
            o = o.parent;
          }
          return false;
        },

        _applyTapaAngleDeg: function (deg) {
          if (!this.tapaObj) return;
          this.tapaAngleDeg = this.clamp(deg, this.data.tapaMinDeg, this.data.tapaMaxDeg);

          // invertido para que abra "bien"
          const rad = -THREE.MathUtils.degToRad(this.tapaAngleDeg);
          const axis = (this.data.tapaAxis || "x").toLowerCase();

          if (axis === "x") this.tapaObj.rotation.x = rad;
          else if (axis === "y") this.tapaObj.rotation.y = rad;
          else this.tapaObj.rotation.z = rad;
        },

        onPointerDown: function (e) {
          if (e.pointerType !== "touch") return;
          if (e.cancelable) e.preventDefault();

          try { e.target.setPointerCapture(e.pointerId); } catch (_) {}

          this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          // 2 dedos -> pinch siempre
          if (this.pointers.size === 2) {
            this.isPinching = true;
            this.isRotating = false;
            this.draggingPart = null;

            this.prevDist = this._dist2Pointers();
            return;
          }

          // 1 dedo
          if (this.pointers.size === 1) {
            const hits = this._intersectModel(e.clientX, e.clientY);
            const touchedTapa = hits.length > 0 && this._hitIsTapa(hits[0].object);

            if (touchedTapa) {
              this.draggingPart = "tapa";
              this.isRotating = false;
              this.isPinching = false;

              // intención por defecto según ángulo actual
              const mid = (this.data.tapaMinDeg + this.data.tapaMaxDeg) / 2; // 90
              this.tapaIntent = (this.tapaAngleDeg >= mid) ? "close" : "open";

              // reset gesture
              this.tapaStartAngleDeg = this.tapaAngleDeg;
              this.tapaAccumPx = 0;
              this.tapaLastX = e.clientX;
              this.tapaLastY = e.clientY;
              return;
            }

            // rotación global
            this.draggingPart = null;
            this.isRotating = true;
            this.isPinching = false;
            this.prevX = e.clientX;
          }
        },

        onPointerMove: function (e) {
          if (e.pointerType !== "touch") return;
          if (!this.pointers.has(e.pointerId)) return;
          if (e.cancelable) e.preventDefault();

          this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          // pinch
          if (this.isPinching && this.pointers.size === 2) {
            const dist = this._dist2Pointers();
            const delta = dist - this.prevDist;
            this.prevDist = dist;

            const factor = 1 + (delta * this.data.zoomSpeed);

            const s = this.el.getAttribute("scale") || { x: 1, y: 1, z: 1 };
            const nx = this.clamp(s.x * factor, this.data.minScale, this.data.maxScale);
            const ny = this.clamp(s.y * factor, this.data.minScale, this.data.maxScale);
            const nz = this.clamp(s.z * factor, this.data.minScale, this.data.maxScale);

            this.el.setAttribute("scale", { x: nx, y: ny, z: nz });
            return;
          }

          // tapa (1 dedo)
          if (this.draggingPart === "tapa" && this.pointers.size === 1) {
            const dx = e.clientX - this.tapaLastX;
            const dy = e.clientY - this.tapaLastY;

            this.tapaLastX = e.clientX;
            this.tapaLastY = e.clientY;

            const step = Math.hypot(dx, dy);
            if (step < 0.5) return;

            const mid = (this.data.tapaMinDeg + this.data.tapaMaxDeg) / 2; // 90

            // OPEN: avance por distancia (curvas ok)
            if (this.tapaIntent === "open") {
              this.tapaAccumPx += step;
              const deltaDeg = this.tapaAccumPx * this.data.tapaDegPerPx;
              this._applyTapaAngleDeg(this.tapaStartAngleDeg + deltaDeg);
              return;
            }

            // CLOSE: U inversa
            // 180->90: dedo ARRIBA (dy<0)
            // 90->0:   dedo ABAJO (dy>0)
            const inTopHalf = this.tapaAngleDeg > mid;
            const expectsUp = inTopHalf;
            const goingUp = dy < 0;
            const goingDown = dy > 0;

            let advancePx = 0;
            if (expectsUp && goingUp) advancePx = step;
            if (!expectsUp && goingDown) advancePx = step;

            if (advancePx <= 0) return;

            this.tapaAccumPx += advancePx;

            const deltaDeg = this.tapaAccumPx * this.data.tapaDegPerPx;
            const candidate = this.tapaStartAngleDeg - deltaDeg;

            // si cruzamos 90, clavamos a 90 y reiniciamos fase
            if (this.tapaStartAngleDeg > mid && candidate <= mid) {
              this._applyTapaAngleDeg(mid);
              this.tapaStartAngleDeg = mid;
              this.tapaAccumPx = 0;
              return;
            }

            this._applyTapaAngleDeg(candidate);
            return;
          }

          // rotación global (1 dedo)
          if (this.isRotating && this.pointers.size === 1) {
            const dx = e.clientX - this.prevX;
            if (Math.abs(dx) < this.data.minMovePx) return;
            this.prevX = e.clientX;
            this.el.object3D.rotation.y += dx * this.data.rotateSpeed;
          }
        },

        onPointerUp: function (e) {
          if (e.pointerType !== "touch") return;
          if (e.cancelable) e.preventDefault();

          this.pointers.delete(e.pointerId);

          if (this.pointers.size === 2) {
            this.isPinching = true;
            this.isRotating = false;
            this.draggingPart = null;
            this.prevDist = this._dist2Pointers();
            return;
          }

          // al soltar, reseteamos modos (evita que se quede pegado)
          this.isPinching = false;
          this.isRotating = false;
          this.draggingPart = null;
          this.prevDist = 0;

          this.tapaAccumPx = 0;
          this.tapaIntent = null;
        }
      });
    </script>
  </body>
</html>








