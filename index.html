<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>

  <body style="margin:0; overflow:hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-gltf-model
          id="modelo"
          src="./carromodelo.glb"
          position="0 0 0"
          rotation="0 0 0"
          scale="2.5 2.5 2.5"
          carrito-controls="
            tapaNode: tapa v1:1;
            wheel1Node: rueda1 v1:1;
            wheel2Node: rueda2 v1:1;

            rotateSpeed: 0.5;
            zoomSpeed: 0.002;
            minScale: 1.0;
            maxScale: 10.0;

            wheelMoveSpeed: 0.002;
            wheelRange: 0.15;

            tapaRotateSpeed: 0.3;
            tapaMinX: -10;
            tapaMaxX: 85;
          "
        ></a-gltf-model>
        <a-entity position="0 0 0">
        <!-- X (rojo) -->
        <a-entity line="start: 0 0 0; end: 0.2 0 0; color: red"></a-entity>
        <!-- Y (verde) -->
        <a-entity line="start: 0 0 0; end: 0 0.2 0; color: green"></a-entity>
        <!-- Z (azul) -->
        <a-entity line="start: 0 0 0; end: 0 0 0.2; color: blue"></a-entity>
      </a-entity>
    </a-scene>

    <script>
      AFRAME.registerComponent("carrito-controls", {
        schema: {
          tapaNode:   { type: "string", default: "tapa v1:1" },
          wheel1Node: { type: "string", default: "rueda1 v1:1" },
          wheel2Node: { type: "string", default: "rueda2 v1:1" },

          rotateSpeed: { type: "number", default: 0.5 },

          zoomSpeed: { type: "number", default: 0.002 },
          minScale:  { type: "number", default: 1.0 },
          maxScale:  { type: "number", default: 10.0 },

          wheelMoveSpeed: { type: "number", default: 0.002 },
          wheelRange:     { type: "number", default: 0.15 },

          // tapa en grados (X)
          tapaRotateSpeed: { type: "number", default: 0.3 },
          tapaMinX:        { type: "number", default: -10 },
          tapaMaxX:        { type: "number", default: 85 },
        },

        init: function () {
          this.modelRoot = null;

          this.tapa = null;
          this.wheel1 = null;
          this.wheel2 = null;

          // posiciones base para limitar relativo (para que no dependan de 0)
          this.baseWheel1X = 0;
          this.baseWheel2X = 0;
          this.baseTapaRotX = 0;

          this.selected = null; // "TAPA" | "W1" | "W2" | null
          this.dragging = false;
          this.pinching = false;

          this.prevX = 0;
          this.prevY = 0;
          this.prevPinchDist = 0;

          this.raycaster = new THREE.Raycaster();
          this.ndc = new THREE.Vector2();

          this.onModelLoaded = this.onModelLoaded.bind(this);
          this.onTouchStart  = this.onTouchStart.bind(this);
          this.onTouchMove   = this.onTouchMove.bind(this);
          this.onTouchEnd    = this.onTouchEnd.bind(this);

          this.el.addEventListener("model-loaded", this.onModelLoaded);

          window.addEventListener("touchstart", this.onTouchStart, { passive: true });
          window.addEventListener("touchmove",  this.onTouchMove,  { passive: true });
          window.addEventListener("touchend",   this.onTouchEnd,   { passive: true });
        },

        remove: function () {
          window.removeEventListener("touchstart", this.onTouchStart);
          window.removeEventListener("touchmove",  this.onTouchMove);
          window.removeEventListener("touchend",   this.onTouchEnd);
        },

        clamp: function (v, min, max) {
          return Math.max(min, Math.min(max, v));
        },

        touchDistance: function (t1, t2) {
          const dx = t2.clientX - t1.clientX;
          const dy = t2.clientY - t1.clientY;
          return Math.hypot(dx, dy);
        },

        onModelLoaded: function () {
          this.modelRoot = this.el.getObject3D("mesh");
          if (!this.modelRoot) return;

          // Busca nodos por nombre
          this.tapa   = this.modelRoot.getObjectByName(this.data.tapaNode);
          this.wheel1 = this.modelRoot.getObjectByName(this.data.wheel1Node);
          this.wheel2 = this.modelRoot.getObjectByName(this.data.wheel2Node);

          // Guarda bases
          if (this.wheel1) this.baseWheel1X = this.wheel1.position.x;
          if (this.wheel2) this.baseWheel2X = this.wheel2.position.x;
          if (this.tapa)   this.baseTapaRotX = this.tapa.rotation.x; // en radianes

          // Debug si no encuentra algo
          if (!this.tapa || !this.wheel1 || !this.wheel2) {
            console.warn("No encontré uno o más nodos. Verifica nombres exactos:", {
              tapaNode: this.data.tapaNode,
              wheel1Node: this.data.wheel1Node,
              wheel2Node: this.data.wheel2Node,
              foundTapa: !!this.tapa,
              foundW1: !!this.wheel1,
              foundW2: !!this.wheel2
            });
            this.modelRoot.traverse((o) => { if (o.name) console.log("NODE:", o.name); });
          }
        },

        pickPart: function (clientX, clientY) {
          const sceneEl = this.el.sceneEl;
          const camera = sceneEl.camera;
          const renderer = sceneEl.renderer;
          if (!camera || !renderer || !this.modelRoot) return null;

          const rect = renderer.domElement.getBoundingClientRect();
          this.ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
          this.ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);

          this.raycaster.setFromCamera(this.ndc, camera);
          const hits = this.raycaster.intersectObject(this.modelRoot, true);
          if (!hits.length) return null;

          const hitObj = hits[0].object;

          const hasAncestorNamed = (obj, name) => {
            let o = obj;
            while (o) {
              if (o.name === name) return true;
              o = o.parent;
            }
            return false;
          };

          if (hasAncestorNamed(hitObj, this.data.tapaNode))   return "TAPA";
          if (hasAncestorNamed(hitObj, this.data.wheel1Node)) return "W1";
          if (hasAncestorNamed(hitObj, this.data.wheel2Node)) return "W2";
          return null;
        },

        onTouchStart: function (event) {
          if (!this.modelRoot) return;

          if (event.touches.length === 2) {
            this.pinching = true;
            this.dragging = false;
            this.prevPinchDist = this.touchDistance(event.touches[0], event.touches[1]);
            return;
          }

          if (event.touches.length === 1) {
            this.pinching = false;
            this.dragging = true;

            const t = event.touches[0];
            this.prevX = t.clientX;
            this.prevY = t.clientY;

            this.selected = this.pickPart(t.clientX, t.clientY); // "TAPA"|"W1"|"W2"|null
          }
        },

        onTouchMove: function (event) {
          if (!this.modelRoot) return;

          // 2 dedos: zoom
          if (this.pinching && event.touches.length === 2) {
            const dist = this.touchDistance(event.touches[0], event.touches[1]);
            const delta = dist - this.prevPinchDist;
            this.prevPinchDist = dist;

            const factor = 1 + (delta * this.data.zoomSpeed);

            const current = this.el.getAttribute("scale") || { x: 1, y: 1, z: 1 };
            const next = {
              x: this.clamp(current.x * factor, this.data.minScale, this.data.maxScale),
              y: this.clamp(current.y * factor, this.data.minScale, this.data.maxScale),
              z: this.clamp(current.z * factor, this.data.minScale, this.data.maxScale),
            };
            this.el.setAttribute("scale", next);
            return;
          }

          // 1 dedo: interactuar o rotar
          if (this.dragging && event.touches.length === 1) {
            const t = event.touches[0];
            const x = t.clientX;
            const y = t.clientY;

            const dx = x - this.prevX;
            const dy = y - this.prevY;

            this.prevX = x;
            this.prevY = y;

            // TAPA: arrastrar arriba/abajo => rotación en X
            if (this.selected === "TAPA" && this.tapa) {
              // dy negativo = dedo sube -> abre (aumenta ángulo)
              const deltaDeg = (-dy) * this.data.tapaRotateSpeed;
              const currentDeg = THREE.MathUtils.radToDeg(this.tapa.rotation.x);
              const nextDeg = this.clamp(currentDeg + deltaDeg, this.data.tapaMinX, this.data.tapaMaxX);
              this.tapa.rotation.x = THREE.MathUtils.degToRad(nextDeg);
              return;
            }

            // RUEDA 1: solo derecha (X+)
            if (this.selected === "W1" && this.wheel1) {
              const delta = dx * this.data.wheelMoveSpeed;
              const onlyRight = Math.max(0, delta); // bloquea izquierda
              const min = this.baseWheel1X;
              const max = this.baseWheel1X + this.data.wheelRange;
              this.wheel1.position.x = this.clamp(this.wheel1.position.x + onlyRight, min, max);
              return;
            }

            // RUEDA 2: solo izquierda (X-)
            if (this.selected === "W2" && this.wheel2) {
              const delta = dx * this.data.wheelMoveSpeed;
              const onlyLeft = Math.min(0, delta); // bloquea derecha
              const min = this.baseWheel2X - this.data.wheelRange;
              const max = this.baseWheel2X;
              this.wheel2.position.x = this.clamp(this.wheel2.position.x + onlyLeft, min, max);
              return;
            }

            // Si no tocaste nada interactivo: rota todo el modelo
            const r = this.el.getAttribute("rotation") || { x: 0, y: 0, z: 0 };

            // 1) Horizontal -> X (derecha = +X, izquierda = -X)
            const dRotX = dx * this.data.rotateSpeed;
            
            // 2) Vertical -> Z (abajo = +Z “hacia adelante”, arriba = -Z “hacia atrás”)
            const dRotZ = dy * this.data.rotateSpeed;
            
            // 3) Diagonal hacia abajo -> Y (solo cuando dy es positivo “abajo”)
            //    derecha-abajo => +Y, izquierda-abajo => -Y
            //    La fuerza depende de cuánto “diagonal” sea (usa el menor de |dx| y |dy| para que sea suave)
            let dRotY = 0;
            if (dy > 0) {
              const diagStrength = Math.min(Math.abs(dx), Math.abs(dy));
              dRotY = Math.sign(dx) * diagStrength * this.data.rotateSpeed;
            }
            
            this.el.setAttribute("rotation", {
              x: r.x + dRotX,
              y: r.y + dRotY,
              z: r.z + dRotZ
            });

          }
        },

        onTouchEnd: function (event) {
          if (event.touches.length < 2) this.pinching = false;

          if (event.touches.length === 0) {
            this.dragging = false;
            this.selected = null;
          }

          if (event.touches.length === 1) {
            const t = event.touches[0];
            this.prevX = t.clientX;
            this.prevY = t.clientY;
          }
        },
      });
    </script>
  </body>
</html>



