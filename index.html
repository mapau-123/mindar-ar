<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>

  <body style="margin:0; overflow:hidden;">
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
      renderer="colorManagement: true; physicallyCorrectLights: true"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- TARGET -->
      <a-entity id="target0" mindar-image-target="targetIndex: 0">

        <!-- PIVOT: aquÃ­ se rota el modelo completo -->
        <a-entity id="pivot" carrito-controls="
          tapaNode: 'tapa v1:1';
          wheel1Node: 'rueda1 v1:1';
          wheel2Node: 'rueda2 v1:1';

          rotateSpeed: 0.5;
          zoomSpeed: 0.002;
          minScale: 1.0;
          maxScale: 10.0;

          wheelMoveSpeed: 0.002;
          wheelRange: 0.15;

          tapaRotateSpeed: 0.3;
          tapaMinX: -10;
          tapaMaxX: 85;
        ">
          <a-gltf-model
            id="modelo"
            src="./carromodelo2.glb"
            position="0 0 0"
            rotation="0 0 0"
            scale="2.5 2.5 2.5"
          ></a-gltf-model>

          <!-- Ejes de referencia -->
          <a-entity position="0 0 0">
            <a-entity line="start: 0 0 0; end: 0.2 0 0; color: red"></a-entity>
            <a-entity line="start: 0 0 0; end: 0 0.2 0; color: green"></a-entity>
            <a-entity line="start: 0 0 0; end: 0 0 0.2; color: blue"></a-entity>
          </a-entity>
        </a-entity>

      </a-entity>
    </a-scene>

    <script>
      AFRAME.registerComponent("carrito-controls", {
      schema: {
        tapaNode:   { type: "string", default: "" },
        wheel1Node: { type: "string", default: "" },
        wheel2Node: { type: "string", default: "" },
    
        rotateSpeed: { type: "number", default: 0.5 },
    
        zoomSpeed: { type: "number", default: 0.002 },
        minScale:  { type: "number", default: 1.0 },
        maxScale:  { type: "number", default: 10.0 },
    
        wheelMoveSpeed: { type: "number", default: 0.002 },
        wheelRange:     { type: "number", default: 0.15 },
    
        tapaRotateSpeed: { type: "number", default: 0.3 },
        tapaMinX:        { type: "number", default: -10 },
        tapaMaxX:        { type: "number", default: 85 },
      },
    
      init: function () {
        this.targetEl = this.el.parentEl;     // mindar-image-target
        this.rotTarget = this.el.object3D;    // pivot
    
        this.modelRoot = null;
        this.tapa = null;
        this.wheel1 = null;
        this.wheel2 = null;
        this.baseWheel1X = 0;
        this.baseWheel2X = 0;
    
        this.selected = null;
        this.dragging = false;
        this.pinching = false;
        this.enabled  = false;
    
        this.prevX = 0;
        this.prevY = 0;
        this.prevPinchDist = 0;
    
        this.raycaster = new THREE.Raycaster();
        this.ndc = new THREE.Vector2();
    
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchMove  = this.onTouchMove.bind(this);
        this.onTouchEnd   = this.onTouchEnd.bind(this);
        this.bindCanvasEvents = this.bindCanvasEvents.bind(this);
    
        // Target found/lost
        if (this.targetEl) {
          this.targetEl.addEventListener("targetFound", () => (this.enabled = true));
          this.targetEl.addEventListener("targetLost",  () => {
            this.enabled = false;
            this.dragging = false;
            this.pinching = false;
            this.selected = null;
          });
        }
    
        // Espera canvas
        this.el.sceneEl.addEventListener("render-target-loaded", this.bindCanvasEvents);
    
        // Encuentra gltf dentro del pivot
        this.gltfEl = this.el.querySelector("a-gltf-model");
    
        // Inicializa el mesh aunque "model-loaded" no dispare
        this.tryInitModelRoot();
      },
    
      remove: function () {
        const canvas = this.el.sceneEl && this.el.sceneEl.canvas;
        if (canvas) {
          canvas.removeEventListener("touchstart", this.onTouchStart);
          canvas.removeEventListener("touchmove",  this.onTouchMove);
          canvas.removeEventListener("touchend",   this.onTouchEnd);
        }
        this.el.sceneEl.removeEventListener("render-target-loaded", this.bindCanvasEvents);
      },
    
      bindCanvasEvents: function () {
        const canvas = this.el.sceneEl && this.el.sceneEl.canvas;
        if (!canvas) return;
    
        canvas.addEventListener("touchstart", this.onTouchStart, { passive: true });
        canvas.addEventListener("touchmove",  this.onTouchMove,  { passive: false });
        canvas.addEventListener("touchend",   this.onTouchEnd,   { passive: true });
      },
    
      clamp: function (v, min, max) {
        return Math.max(min, Math.min(max, v));
      },
    
      touchDistance: function (t1, t2) {
        const dx = t2.clientX - t1.clientX;
        const dy = t2.clientY - t1.clientY;
        return Math.hypot(dx, dy);
      },
    
      // ðŸ”¥ Reintenta hasta que el mesh exista
      tryInitModelRoot: function () {
        if (!this.gltfEl) {
          // aÃºn no estÃ¡ en DOM
          setTimeout(() => this.tryInitModelRoot(), 100);
          return;
        }
    
        const root = this.gltfEl.getObject3D("mesh");
        if (!root) {
          // todavÃ­a no cargÃ³ el glb
          setTimeout(() => this.tryInitModelRoot(), 100);
          return;
        }
    
        // Ya estÃ¡ listo
        this.modelRoot = root;
    
        console.log("=== NODOS DEL GLB ===");
        this.modelRoot.traverse((o) => { if (o.name) console.log("NODE:", o.name); });
    
        this.tapa   = this.modelRoot.getObjectByName(this.data.tapaNode);
        this.wheel1 = this.modelRoot.getObjectByName(this.data.wheel1Node);
        this.wheel2 = this.modelRoot.getObjectByName(this.data.wheel2Node);
    
        if (this.wheel1) this.baseWheel1X = this.wheel1.position.x;
        if (this.wheel2) this.baseWheel2X = this.wheel2.position.x;
    
        if (!this.tapa || !this.wheel1 || !this.wheel2) {
          console.warn("No encontrÃ© uno o mÃ¡s nodos:", {
            tapaNode: this.data.tapaNode,
            wheel1Node: this.data.wheel1Node,
            wheel2Node: this.data.wheel2Node,
            foundTapa: !!this.tapa,
            foundW1: !!this.wheel1,
            foundW2: !!this.wheel2
          });
        }
      },
    
      pickPart: function (clientX, clientY) {
        const sceneEl = this.el.sceneEl;
        const camera = sceneEl.camera;
        const renderer = sceneEl.renderer;
        if (!camera || !renderer || !this.modelRoot) return null;
    
        const rect = renderer.domElement.getBoundingClientRect();
        this.ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        this.ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);
    
        this.raycaster.setFromCamera(this.ndc, camera);
        const hits = this.raycaster.intersectObject(this.modelRoot, true);
        if (!hits.length) return null;
    
        const hitObj = hits[0].object;
    
        const hasAncestorNamed = (obj, name) => {
          let o = obj;
          while (o) {
            if (o.name === name) return true;
            o = o.parent;
          }
          return false;
        };
    
        if (hasAncestorNamed(hitObj, this.data.tapaNode))   return "TAPA";
        if (hasAncestorNamed(hitObj, this.data.wheel1Node)) return "W1";
        if (hasAncestorNamed(hitObj, this.data.wheel2Node)) return "W2";
        return null;
      },
    
      onTouchStart: function (event) {
        if (!this.enabled) return;
    
        if (event.touches.length === 2) {
          this.pinching = true;
          this.dragging = false;
          this.prevPinchDist = this.touchDistance(event.touches[0], event.touches[1]);
          return;
        }
    
        if (event.touches.length === 1) {
          this.pinching = false;
          this.dragging = true;
    
          const t = event.touches[0];
          this.prevX = t.clientX;
          this.prevY = t.clientY;
    
          // Solo intenta seleccionar partes si ya existe modelRoot
          this.selected = this.modelRoot ? this.pickPart(t.clientX, t.clientY) : null;
        }
      },
    
      onTouchMove: function (event) {
        if (!this.enabled) return;
    
        if (event.cancelable) event.preventDefault();
    
        // âœ… Zoom NO depende de modelRoot
        if (this.pinching && event.touches.length === 2) {
          const dist = this.touchDistance(event.touches[0], event.touches[1]);
          const delta = dist - this.prevPinchDist;
          this.prevPinchDist = dist;
    
          const factor = 1 + (delta * this.data.zoomSpeed);
    
          const current = this.targetEl.getAttribute("scale") || { x: 1, y: 1, z: 1 };
          const next = {
            x: this.clamp(current.x * factor, this.data.minScale, this.data.maxScale),
            y: this.clamp(current.y * factor, this.data.minScale, this.data.maxScale),
            z: this.clamp(current.z * factor, this.data.minScale, this.data.maxScale),
          };
    
          this.targetEl.setAttribute("scale", next);
          return;
        }
    
        if (this.dragging && event.touches.length === 1) {
          const t = event.touches[0];
          const x = t.clientX;
          const y = t.clientY;
    
          const dx = x - this.prevX;
          const dy = y - this.prevY;
    
          this.prevX = x;
          this.prevY = y;
    
          // âœ… Partes: solo si ya estÃ¡ listo el mesh
          if (this.modelRoot) {
            if (this.selected === "TAPA" && this.tapa) {
              const deltaDeg = (-dy) * this.data.tapaRotateSpeed;
              const currentDeg = THREE.MathUtils.radToDeg(this.tapa.rotation.x);
              const nextDeg = this.clamp(currentDeg + deltaDeg, this.data.tapaMinX, this.data.tapaMaxX);
              this.tapa.rotation.x = THREE.MathUtils.degToRad(nextDeg);
              return;
            }
    
            if (this.selected === "W1" && this.wheel1) {
              const delta = dx * this.data.wheelMoveSpeed;
              const onlyRight = Math.max(0, delta);
              const min = this.baseWheel1X;
              const max = this.baseWheel1X + this.data.wheelRange;
              this.wheel1.position.x = this.clamp(this.wheel1.position.x + onlyRight, min, max);
              return;
            }
    
            if (this.selected === "W2" && this.wheel2) {
              const delta = dx * this.data.wheelMoveSpeed;
              const onlyLeft = Math.min(0, delta);
              const min = this.baseWheel2X - this.data.wheelRange;
              const max = this.baseWheel2X;
              this.wheel2.position.x = this.clamp(this.wheel2.position.x + onlyLeft, min, max);
              return;
            }
          }
    
          // âœ… RotaciÃ³n del modelo completo (no depende de modelRoot)
          const obj = this.rotTarget || this.el.object3D;
          const s = 0.005 * this.data.rotateSpeed;
    
          const pitch = dy * s;
          const yaw   = dx * s;
    
          const cam = this.el.sceneEl.camera;
          if (cam) {
            const camWorldQuat = new THREE.Quaternion();
            cam.getWorldQuaternion(camWorldQuat);
    
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camWorldQuat).normalize();
            const up    = new THREE.Vector3(0, 1, 0);
    
            const qYaw   = new THREE.Quaternion().setFromAxisAngle(up,    yaw);
            const qPitch = new THREE.Quaternion().setFromAxisAngle(right, pitch);
    
            obj.quaternion.premultiply(qYaw);
            obj.quaternion.premultiply(qPitch);
          } else {
            obj.rotateX(pitch);
            obj.rotateY(yaw);
          }
        }
      },
    
      onTouchEnd: function (event) {
        if (!this.enabled) return;
    
        if (event.touches.length < 2) this.pinching = false;
    
        if (event.touches.length === 0) {
          this.dragging = false;
          this.selected = null;
        }
    
        if (event.touches.length === 1) {
          const t = event.touches[0];
          this.prevX = t.clientX;
          this.prevY = t.clientY;
        }
      },
    });

    </script>
  </body>
</html>





