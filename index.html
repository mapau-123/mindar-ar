<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <style>
      html, body { margin: 0; overflow: hidden; }
      body { touch-action: none; }
    </style>
  </head>

  <body>
    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0">
        <a-gltf-model
          id="modelo"
          src="./modcarro.glb"
          position="0 0 0"
          rotation="0 0 0"
          scale="5 5 5"
          gesture-controls="tapaName: tapa_v31; tapaAxis: x; tapaMaxDeg: 180; tapaDegPerPx: 0.5;"
        ></a-gltf-model>
      </a-entity>
    </a-scene>

    <script>
      AFRAME.registerComponent("gesture-controls", {
        schema: {
          // Pinch zoom
          zoomSpeed: { type: "number", default: 0.0025 },
          minScale:  { type: "number", default: 0.8 },
          maxScale:  { type: "number", default: 15.0 },

          // Rotaci√≥n global (1 dedo)
          rotateSpeed: { type: "number", default: 0.008 }, // rad/pixel
          minMovePx:   { type: "number", default: 1 },

          // Tapa interactiva
          tapaName:     { type: "string", default: "tapa_v31" },
          tapaAxis:     { type: "string", default: "x" },   // "x" | "y" | "z"
          tapaMinDeg:   { type: "number", default: 0 },
          tapaMaxDeg:   { type: "number", default: 180 },
          tapaDegPerPx: { type: "number", default: 0.5 }    // grados por pixel vertical
        },

        init: function () {
          this.canvas = null;
          this.camera = null;

          // pointers activos: id -> {x,y}
          this.pointers = new Map();

          // estados
          this.isPinching = false;
          this.isRotating = false;

          // interacci√≥n de pieza
          this.draggingPart = null; // "tapa" | null
          this.dragStartY = 0;
          this.tapaAngleDeg = 0;       // estado actual 0..180
          this.tapaStartAngleDeg = 0;  // para calcular delta durante el drag

          // Tapa: drag m√°s natural (por distancia recorrida)
          this.tapaIntent = null;     // "open" | "close" | null
          this.tapaAccumPx = 0;       // distancia acumulada del gesto
          this.tapaLastX = 0;
          this.tapaLastY = 0;
          this.intentThresholdPx = 6; // umbral para decidir intenci√≥n
          this.flipThresholdPx = 14;       // cuanto ‚Äúcontra‚Äù debe moverse para cambiar intenci√≥n
          this.tapaAgainstPx = 0;          // acumulado en contra (para flip)

          // refs THREE
          this.modelRoot = null;
          this.tapaObj = null;

          // raycast
          this.raycaster = new THREE.Raycaster();
          this.ndc = new THREE.Vector2();

          this.prevDist = 0;
          this.prevX = 0;

          this.onPointerDown = this.onPointerDown.bind(this);
          this.onPointerMove = this.onPointerMove.bind(this);
          this.onPointerUp   = this.onPointerUp.bind(this);

          this.el.addEventListener("model-loaded", () => {
            this.modelRoot = this.el.object3D;
            this.modelRoot.add(new THREE.AxesHelper(0.6));

            this.tapaObj = this.modelRoot.getObjectByName(this.data.tapaName);
            if (this.tapaObj) {
              this.tapaObj.add(new THREE.AxesHelper(0.3));
              console.log("‚úÖ Tapa encontrada:", this.data.tapaName);
            } else {
              console.warn("‚ö†Ô∏è No encontr√© la tapa con nombre:", this.data.tapaName);
            }

            console.log("‚úÖ model-loaded OK");
          });

          this.el.addEventListener("model-error", (e) => {
            console.error("‚ùå Error cargando GLB:", e?.detail || e);
          });

          // Esperar renderer/canvas/c√°mara reales
          const waitForCanvas = () => {
            const scene = this.el.sceneEl;
            if (scene && scene.renderer && scene.renderer.domElement && scene.camera) {
              this.canvas = scene.renderer.domElement;
              this.camera = scene.camera;

              this.canvas.style.touchAction = "none";

              this.canvas.addEventListener("pointerdown", this.onPointerDown, { passive: false, capture: true });
              window.addEventListener("pointermove", this.onPointerMove, { passive: false, capture: true });
              window.addEventListener("pointerup", this.onPointerUp, { passive: false, capture: true });
              window.addEventListener("pointercancel", this.onPointerUp, { passive: false, capture: true });

              console.log("‚úÖ Pointer events activos");
            } else {
              setTimeout(waitForCanvas, 100);
            }
          };
          waitForCanvas();
        },

        remove: function () {
          if (!this.canvas) return;
          this.canvas.removeEventListener("pointerdown", this.onPointerDown, { capture: true });
          window.removeEventListener("pointermove", this.onPointerMove, { capture: true });
          window.removeEventListener("pointerup", this.onPointerUp, { capture: true });
          window.removeEventListener("pointercancel", this.onPointerUp, { capture: true });
        },

        clamp: function (v, min, max) {
          return Math.max(min, Math.min(max, v));
        },

        _dist2Pointers: function () {
          const arr = Array.from(this.pointers.values());
          if (arr.length < 2) return 0;
          const dx = arr[1].x - arr[0].x;
          const dy = arr[1].y - arr[0].y;
          return Math.hypot(dx, dy);
        },

        _intersectModel: function (clientX, clientY) {
          if (!this.canvas || !this.camera || !this.modelRoot) return [];
          const rect = this.canvas.getBoundingClientRect();

          this.ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
          this.ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);

          this.modelRoot.updateMatrixWorld(true);
          this.raycaster.setFromCamera(this.ndc, this.camera);

          return this.raycaster.intersectObject(this.modelRoot, true);
        },

        _hitIsTapa: function (hitObj) {
          if (!this.tapaObj) return false;
          // El hit puede ser un mesh hijo: subimos por parent hasta encontrar tapaObj
          let o = hitObj;
          while (o) {
            if (o === this.tapaObj) return true;
            o = o.parent;
          }
          return false;
        },

        _applyTapaAngleDeg: function (deg) {
          if (!this.tapaObj) return;
          this.tapaAngleDeg = this.clamp(deg, this.data.tapaMinDeg, this.data.tapaMaxDeg);

          const rad = -THREE.MathUtils.degToRad(this.tapaAngleDeg);
          const axis = (this.data.tapaAxis || "x").toLowerCase();

          // Si al girar te queda al rev√©s, invierte el signo (rad -> -rad)
          if (axis === "x") this.tapaObj.rotation.x = rad;
          else if (axis === "y") this.tapaObj.rotation.y = rad;
          else this.tapaObj.rotation.z = rad;
        },

        onPointerDown: function (e) {
          if (e.pointerType !== "touch") return;
          if (e.cancelable) e.preventDefault();

          try { e.target.setPointerCapture(e.pointerId); } catch (_) {}

          this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          // 2 dedos -> pinch siempre
          if (this.pointers.size === 2) {
            this.isPinching = true;
            this.isRotating = false;
            this.draggingPart = null;

            this.prevDist = this._dist2Pointers();
            return;
          }

          // 1 dedo -> ver si toc√≥ la tapa
          if (this.pointers.size === 1) {
            // Intentar detectar tapa con raycast
            const hits = this._intersectModel(e.clientX, e.clientY);

            const touchedTapa = hits.length > 0 && this._hitIsTapa(hits[0].object);

            if (touchedTapa) {
              this.draggingPart = "tapa";
              this.isRotating = false;
              this.isPinching = false;
            
              this.tapaStartAngleDeg = this.tapaAngleDeg;
            
              // üëá Intenci√≥n por defecto seg√∫n qu√© tan abierta est√°
              const mid = (this.data.tapaMinDeg + this.data.tapaMaxDeg) / 2;
              this.tapaIntent = (this.tapaAngleDeg >= mid) ? "close" : "open";
            
              // reset del gesto
              this.tapaAccumPx = 0;
              this.tapaAgainstPx = 0;
              this.tapaLastX = e.clientX;
              this.tapaLastY = e.clientY;
            
              return;
            }

            // si no toc√≥ tapa: rotaci√≥n global
            this.draggingPart = null;
            this.isRotating = true;
            this.isPinching = false;
            this.prevX = e.clientX;
          }
        },

        onPointerMove: function (e) {
          if (e.pointerType !== "touch") return;
          if (!this.pointers.has(e.pointerId)) return;
          if (e.cancelable) e.preventDefault();

          this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          // pinch
          if (this.isPinching && this.pointers.size === 2) {
            const dist = this._dist2Pointers();
            const delta = dist - this.prevDist;
            this.prevDist = dist;

            const factor = 1 + (delta * this.data.zoomSpeed);

            const s = this.el.getAttribute("scale") || { x: 1, y: 1, z: 1 };
            const nx = this.clamp(s.x * factor, this.data.minScale, this.data.maxScale);
            const ny = this.clamp(s.y * factor, this.data.minScale, this.data.maxScale);
            const nz = this.clamp(s.z * factor, this.data.minScale, this.data.maxScale);

            this.el.setAttribute("scale", { x: nx, y: ny, z: nz });
            return;
          }

          // arrastre de tapa (1 dedo)
          if (this.draggingPart === "tapa" && this.pointers.size === 1) {
            const dx = e.clientX - this.tapaLastX;
            const dy = e.clientY - this.tapaLastY;
          
            this.tapaLastX = e.clientX;
            this.tapaLastY = e.clientY;
          
            const step = Math.hypot(dx, dy);
            if (step < 0.5) return;
          
            // OPEN: se comporta como ya te gust√≥ (avance por distancia, sin importar la curva)
            if (this.tapaIntent === "open") {
              this.tapaAccumPx += step;
              const deltaDeg = this.tapaAccumPx * this.data.tapaDegPerPx;
              const nextDeg = this.tapaStartAngleDeg + deltaDeg;
              this._applyTapaAngleDeg(nextDeg);
              return;
            }
          
            // CLOSE (modo U inversa):
            // 180 -> 90: gesto esperado = ARRIBA (dy < 0)
            // 90  -> 0 : gesto esperado = ABAJO (dy > 0)
          
            const mid = (this.data.tapaMinDeg + this.data.tapaMaxDeg) / 2; // 90 si 0..180
            const inTopHalf = this.tapaAngleDeg > mid;
          
            const expectsUp = inTopHalf;      // 180..90
            const expectsDown = !inTopHalf;   // 90..0
          
            const goingUp = dy < 0;
            const goingDown = dy > 0;
          
            // magnitud a acumular (permitimos diagonales pero el "sentido" lo manda dy)
            const mag = step;
          
            // Si el usuario se mueve en el sentido esperado, avanzamos cierre
            let advancePx = 0;
            if (expectsUp && goingUp) advancePx = mag;
            if (expectsDown && goingDown) advancePx = mag;
          
            // Si no va en el sentido esperado, no avanzamos (evita que se sienta "raro")
            if (advancePx <= 0) return;
          
            // OJO: cuando cambias de mitad (cruzas 90¬∞), reinicia base para que no pegue saltos
            // Detectamos cambio de fase si el pr√≥ximo √°ngulo cruzar√≠a el mid.
            this.tapaAccumPx += advancePx;
          
            const deltaDeg = this.tapaAccumPx * this.data.tapaDegPerPx;
            const candidate = this.tapaStartAngleDeg - deltaDeg;
          
            // Si vamos a cruzar el mid, clavamos exactamente al mid y reiniciamos acumulados
            if (this.tapaStartAngleDeg > mid && candidate <= mid) {
              this._applyTapaAngleDeg(mid);
              this.tapaStartAngleDeg = mid;
              this.tapaAccumPx = 0;
              return;
            }
          
            this._applyTapaAngleDeg(candidate);
            return;
          }
          
            // Avance acumulado (permite curvas naturales)
            this.tapaAccumPx += step;
          
            const deltaDeg = this.tapaAccumPx * this.data.tapaDegPerPx;
            const nextDeg =
              this.tapaIntent === "open"
                ? (this.tapaStartAngleDeg + deltaDeg)
                : (this.tapaStartAngleDeg - deltaDeg);
          
            this._applyTapaAngleDeg(nextDeg);
            return;
          }

          // rotaci√≥n global (1 dedo)
          if (this.isRotating && this.pointers.size === 1) {
            const dx = e.clientX - this.prevX;
            if (Math.abs(dx) < this.data.minMovePx) return;
            this.prevX = e.clientX;

            this.el.object3D.rotation.y += dx * this.data.rotateSpeed;
          }
        },

        onPointerUp: function (e) {
          if (e.pointerType !== "touch") return;
          if (e.cancelable) e.preventDefault();

          this.pointers.delete(e.pointerId);

          if (this.pointers.size === 2) {
            this.isPinching = true;
            this.isRotating = false;
            this.draggingPart = null;
            this.prevDist = this._dist2Pointers();
            return;
          }

          if (this.pointers.size === 1) {
            // No reactivamos nada autom√°tico: esperamos nuevo pointerdown
            this.isPinching = false;
            this.isRotating = false;
            this.draggingPart = null;
            this.prevDist = 0;
            return;
          }

          this.isPinching = false;
          this.isRotating = false;
          this.draggingPart = null;
          this.prevDist = 0;
          this.tapaAccumPx = 0;
          this.tapaAgainstPx = 0;
          this.tapaIntent = null;
        }
      });
    </script>
  </body>
</html>






